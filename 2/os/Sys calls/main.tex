\input{settings.tex}
\begin{document}
\input{title.tex}
\input{ToC.tex}

\section{Цель работы}
\par Изучить заданные системные вызовы, проанализировать их исходный код. Осуществить перехват заданных системных вызовов для ядер ОС Linux версий 3.х и 4.x

\section{План работы}
В данной работе, для заданных системных функций необходимо:
\begin{enumerate}
    \item ознакомиться с функциональностью и параметрами;
    \item изучить исходный код;
    \item произвести перехват;
    \item модифицировать исходный код.
\end{enumerate}

\par Заданные системные вызовы:
\begin{itemize}
    \item time
    \item alarm
\end{itemize}

\par Работа будет производиться для следующих версий ядер:
\begin{itemize}
\item \textbf{3.11.0-15-generic} - \textbf{Ubuntu 12.04}
\item \textbf{4.4.0-142-generic} - \textbf{Ubuntu 14.04}
\end{itemize}

\section{Сведения о системе}
\par Данная лабораторная работа выполнялась на двух виртуальных машинах, с соответсвующими ядрами.

\par Сведения о первой системе
\lstinputlisting{logs/sys-info-bubuntu12.txt}

\par Сведения о второй системе
\lstinputlisting{logs/sys-info-bubuntu14.txt}

\clearpage

\section{Выполнение работы}

\subsection{Системные вызовы} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Системный вызов — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.

\par Современные операционные системы предусматривают разделение времени между выполняющимися вычислительными процессами (многозадачность) и разделение полномочий, препятствующее обращению исполняемых программ к данным других программ и оборудованию. Ядро ОС исполняется в привилегированном режиме работы процессора. Для выполнения межпроцессной операции или операции, требующей доступа к оборудованию, программа обращается к ядру, которое, в зависимости от полномочий вызывающего процесса, исполняет либо отказывает в исполнении такого вызова.

\par С точки зрения программиста, системный вызов обычно выглядит как вызов подпрограммы или функции из системной библиотеки. Однако системный вызов, как частный случай вызова такой функции или подпрограммы, следует отличать от более общего обращения к системной библиотеке, поскольку последнее может и не требовать выполнения привилегированных операций.

\subsection{Заданные системные вызовы} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Для исследования, в данной лабораторной работе, были заданы следующие системные вызовы:

\begin{itemize}
    \item sys\_time 
    \item sys\_alarm
\end{itemize}


\par Прежде всего необходимо привести сигнатуры данных функций.

\begin{center}
    \item \textbf{\#include <time.h>}
    \item \textbf{\#include <unistd.h>}
\end{center}

\begin{center}
    \item time\_t time(time\_t *tloc); 
    \item unsigned int alarm(unsigned int seconds);
\end{center}

\par time() возвращает количество секунд, которое прошло с начала эпохи, 1970-01-01 00:00:00 +0000 (UTC). Если tloc не равно NULL, то возвращаемое значение также сохраняется в область памяти, на которую указывает tloc. \\

\par При удачном завершении работы возвращается время в секундах, прошедшее с начала эпохи. При ошибке возвращается ((time\_t) -1), а errno устанавливается должным образом. \\


\par Системный вызов alarm() размещает сигнал SIGALRM для доставки вызывающему процессу через seconds секунд.
Если значение seconds равно 0, то любой ожидающий будильник будет отменён.
При любом событии ранее запланированный alarm() отменяется. \\

\par alarm() и setitimer() используют один и тот же таймер; они будут мешать работе друг друга.

\subsubsection{Возможные ошибки системных вызовов}

\begin{itemize}
    \item EFAULT - tloc указывает за пределы доступного адресного пространства. В системах, где обёрточная функция time() библиотеки C вызывает реализацию, предоставляемую vdso() (то есть нет ловушки в ядре), из-за некорректного адреса может генерироваться сигнал SIGSEGV.
\end{itemize}


\subsection{Анализ исходного кода time} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Исходный код системныго вызова time проанализирован для следующих ядер.

\subsubsection{Ядро 3.11.0-15-generic}

\par Ниже приведен исходный код time
\lstinputlisting{listings/time.c}

\par $SYSCALL\_DEFINE1$ -- макрос используемый для определения системных вызовов, цифра 1 означает количество параметров у системного вызова.

\par В данном системном вызове для определения времени используется функция $get\_seconds()$, ниже приведен её исходный код:

\lstinputlisting{listings/get_seconds.c}

\par Данная функция обращается к структуре данного процесса из которой и получает его текущий приоритет.

\subsubsection{Ядро 4.4.0-142-generic}

\par При поиске исходного кода time для ядра 4.x был найден абсолютно идентичный код относительно второго ядра. Поэтому дублировать исходный код не имеет смысла.


\subsection{Анализ исходного кода alarm} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Исходный код системныго вызова alarm проанализирован для следующих ядер.

\subsubsection{Ядро 3.11.0-15-generic}

\par Ниже приведен исходный код alarm
\lstinputlisting{listings/alarm.c}

\par $SYSCALL\_DEFINE1$ -- макрос используемый для определения системных вызовов, цифра 1 означает количество параметров у системного вызова. 

\par Вызов по сути использует функцию $alarm\_setitimer()$. Ее код приведен ниже

\lstinputlisting{listings/alarm_setitimer.c}

\par Для установки таймера используется $do\_setitimer()$. Ее код приведен ниже

\lstinputlisting{listings/do_setitimer.c}


\subsubsection{Ядро 4.4.0-142-generic}

\par При поиске исходного кода alarm для ядра 4.x был найден абсолютно идентичный код относительно второго ядра. Поэтому дублировать исходный код не имеет смысла.


\subsection{Работа системных вызовов} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Напишем простую программу, которые сначала будет устанавливать обработчик на сигнал SIGALARM, а потом сделаем вызов alarm с задержкой в 5 секунд и программу, которая печатает время через вызов time. Так как исходный код системных вызовов идентичен для ядер 3.11.0-15-generic и 4.4.0-142-generic, запускать будем только на одной системе с ядром 3.11.0-15-generic, так как результат в системе с ядром 4.х будет аналогичным. Ниже приведен исходный код, написанной программы:

\lstinputlisting{listings/alarm_sys_call.c}

\lstinputlisting{listings/time_sys_call.c}

\par После компиляции и запуска программ получили следующее:

\lstinputlisting{logs/alarm_log.txt}

\lstinputlisting{logs/time_log.txt}


\par Из результатов видно, что программы закончились успешно. Программа вызывающая системный вызов time() вывела на экран количество секунд, а вызов alarm() отправил программе сигнал SIGALARM, который был отловлен в обработчике.

\par Далее можно выполнить трассировку, написанной программы. Ниже представлен лог трассировки:

 \lstinputlisting{logs/alarm_strace.txt}
 
  \lstinputlisting{logs/time_strace.txt}

\par В результате трассировки видно, что  последовательность вызовов системных функций совпадает с ожидаемой.



\subsection{Перехват системных вызовов} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Ядро 3.11.0-15-generic}

\textbf{khook}

\par Данный способ перехвата системного вызова будет основываться на готовой библиотеке khook. Данная библиотека реализует перехват с помощью вносимых модификаций в пролог (начало) целевой функции таким образом, чтобы его выполнение процессором приводило передаче управления на функцию-обработчик. \\

\par Для каждой целевой функции осуществим модификацию пролога путём записи в её начало команды JMP . Это позволит переключить поток выполнения с целевой функции на соответствующий обработчик. \\ 

\par Например, если до перехвата функция inode\_permission имеет вид:

 \lstinputlisting{logs/theory-hook1.txt}

\par То после перехвата, пролог этой функции будет выглядеть следующим образом:

 \lstinputlisting{logs/theory-hook2.txt}

\par Именно записанная поверх оригинальных инструкций пяти-байтовая команда JMP с кодом E9.XX.XX.XX.XX приводит к передачи управления. В этом и состоит основная суть описываемого способа осуществления перехвата. Далее будут рассмотрены некоторые особенности его реализации в ядре Linux.

\par Как было отмечено, суть патчинга заключается в модификации кода ядра. Основной проблемой, возникающей при этом является то, что запись в страницы памяти, содержащие код невозможна так как в архитектуре x86 существует специальный защитный механизм, в соответствии с которым попытка записи в защищённые от записи области памяти может приводить к генерации исключения. Данный механизм носит название «страничной защиты» и является базовым для реализации многих функций ядра, таких, как например COW. Поведение процессора в этой ситуации определяется битом WP регистра CR0, а права доступа к странице описываются в соответствующей ей структуре-описателе PTE. При установленном бите WP регистра CR0 попытка записи в защищённые от записи страницы (cброшен бит RW в PTE) ведёт к генерации процессором соответствующего исключения (\#GP).

\par Зачастую, решением данной проблемы является временное отключение страничной защиты сбросом бита WP регистра CR0. Это решение имеет место быть, однако \textbf{применять его нужно с осторожностью}, ведь как было отмечено, механизм страничной защиты является \textbf{основой для многих механизмов ядра}. Кроме того, на SMP-системах, поток, выполняющийся на одном из процессоров и там же снимающий бит WP, может быть прерван и перемещён на другой процессор!

\par Более лучшим и в достаточной степени универсальным, является способ создания временных отображений. В силу особенностей работы MMU, для каждого физического фрейма памяти может быть создано несколько ссылающихся на него описателей, имеющих различные атрибуты. Это позволяет создать для целевой области памяти отображение, доступное для записи. Ниже приведена функция map\_writable, которая и создаёт такое отображение:

\clearpage

\lstinputlisting{logs/theory-hook3.txt}

\par Использование данной функции позволит создать доступное для записи отображение для любой области памяти. Освобождение созданного таким образом региона осуществляется с использованием функции vfree, аргументом которой должно служить выравненное на границу страницы значение адреса.\\

\textbf{Попытка перехвата}

\par Напишем модуль ядра для перехвата системных вызовов:

\lstinputlisting{listings/khook.c}

\par Далее скомпилируем модуль:

\lstinputlisting[firstline=1, lastline=47]{logs/khook1.txt}

\par Далее загрузим получившийся модуль:

\lstinputlisting{logs/khook2.txt}

\par Далее запустим приложение, демонстрирующее работы системных вызовов:

\lstinputlisting{logs/khook3.txt}

\par Далее можно выгрузить модуль и выполнить команду make clean, которая удалит сгенерированные файлы :

\lstinputlisting{logs/khook5.txt}


\par После всех выполненных манипуляций убедимся, что перехват системных вызовов был выполнен. Для этого посмотрим лог ядра:

\lstinputlisting{logs/khook4.txt}





\subsubsection{Ядро 4.4.0-142-generic} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Начиная с версии ядра 3.19 перехват системных вызовов с помощью фреймворка ftrace, на ОС семейства Linux x86\_64, работает штатно.

\par Реализуется ftrace на основе ключей компилятора -pg и -mfentry, которые вставляют в начало каждой функции вызов специальной трассировочной функции mcount() или \_\_fentry\_\_(). Обычно, в пользовательских программах эта возможность компилятора используется профилировщиками, чтобы отслеживать вызовы всех функций. Ядро же использует эти функции для реализации фреймворка ftrace.

\par Вызывать ftrace из каждой функции -- это, разумеется, не дёшево, поэтому для популярных архитектур доступна оптимизация: динамический ftrace. Суть в том, что ядро знает расположение всех вызовов mcount() или \_\_fentry\_\_() и на ранних этапах загрузки заменяет их машинный код на nop — специальную ничего не делающую инструкцию. При включении трассирования в нужные функции вызовы ftrace добавляются обратно. Таким образом, если ftrace не используется, то его влияние на систему минимально.

\par Рассмотрим необходимую для работы с ftrace структуру:

\lstinputlisting[firstline=45, lastline=52]{listings4/ftrace_hook.c}

\begin{itemize}
	\item name -- имя перехватываемой функции
	\item function -- адрес функции обработчика 
	\item original -- указатель на ячейку для хранения адреса оригинального обработчика
	\item address -- адрес перехватываемой функции, заполняется во время перехвата
	\item ops -- место под сервисную информацию
\end{itemize}

\par Для работы необходимо заполнить только три поля данной структуры: \lstinline|name, function, original|. Для удобства использования можно применить макрос:

\lstinputlisting[firstline=237, lastline=240]{listings/ftrace_hook.c}

\par Напишем свои функции перехвата для alarm и time.

\par Сначала приводим сигнатуры функций:
\lstinputlisting[firstline=186, lastline=188]{listings/ftrace_hook.c}

\par Важно учесть оригинальную сигнатуру функции, она должна полностью соответствовать используемой в перехвате, в противном случае существует риск получить невалидные аргументы, что скажется на работе всей функции и перехвата в целом.

\par Далее приводим реализацию функций:
\lstinputlisting[firstline=190, lastline=216]{listings/ftrace_hook.c}


\par Прежде всего надо найти и сохранить адрес перехватываемой функции. Для этого воспользуемся \textit{kallsyms} -- список всех символов в ядре. Так выглядит функция поиска:

\lstinputlisting[firstline=54, lastline=66]{listings4/ftrace_hook.c}

\par Теперь необходимо инициализировать \lstinline|ops| структуру, \lstinline|func| указатель на обратный вызов и флаги: 

\lstinputlisting[firstline=83, lastline=110]{listings4/ftrace_hook.c}

\lstinline|fh\_ftrace\_thunk ()| -- это обратный вызов который используется при трассировке функции. Флаги необходимы для сохранения и восстановления состояния регистров процессора. 

\par Для установки перехвата сначала запускается ftrace для необходимой функции \lstinline|ftrace\_set\_filter\_ip()|, затем используется\lstinline|register\_ftrace\_function()| для передачи ftrace необходимых для обратного вызова прав.

\par Для дезактивации перехвата необходимо повторить те же самые действия в обратном порядке:

\lstinputlisting[firstline=116, lastline=129]{listings4/ftrace_hook.c}

\clearpage

\par Далее компилируем модуль ядра
\lstinputlisting[firstline=1, lastline=12]{logs/4log-full.txt}

\par Установим получившийся модуль, и запустим приложение, которое проверяет работу системных вызовов

\lstinputlisting[firstline=13, lastline=13]{logs/4log-full.txt}

\par Удостоверяемся, что программа выполнилась успешно. Далее можно выгрузить модуль и выполнить команду $make clean$, которая удалит сгенерированные файлы.

\lstinputlisting[firstline=16, lastline=23]{logs/4log-full.txt}

\par После всех выполненных манипуляций убедимся, что перехват системных вызовов был выполнен. Для этого посмотрим лог ядра:

\lstinputlisting{logs/4log-syslog.txt}

\par Из лога видно, что модуль был загружен, затем были перехвачены системные вызовы, и в конце модуль был выгружен. Перехват системных вызовов был выполнен в том же порядке, как и в программе, демонстрирующей работы системных вызовов.

\subsection{Вывод} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\par В ходе выполнения данной лабораторной работы были исследованы системные вызов \textbf{alarm} и \textbf{time}. Для данных системных вызовов был: проанализирован исходный код (в различных версиях ядер), а также написан тестовый пример использования и был произведен перехват.

\clearpage

\input{literarture.tex}

\end{document}