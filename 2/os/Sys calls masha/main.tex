\input{settings.tex}
\begin{document}
\input{title.tex}
\input{ToC.tex}

\section{Цель работы}
\par Изучить заданные системные вызовы, проанализировать их исходный код. Осуществить перехват заданных системных вызовов для ядер ОС Linux версий 3.х и 4.x

\section{План работы}
В данной работе, для заданных системных функций необходимо:
\begin{enumerate}
    \item ознакомиться с функциональностью и параметрами;
    \item изучить исходный код;
    \item произвести перехват;
    \item модифицировать исходный код.
\end{enumerate}

\par Заданные системные вызовы:
\begin{itemize}
    \item chmod
    \item chown
\end{itemize}

\par Работа будет производиться для следующих версий ядер:
\begin{itemize}
\item \textbf{3.11.0-15-generic} - \textbf{Ubuntu 12.04}
\item \textbf{4.4.0-142-generic} - \textbf{Ubuntu 14.04}
\end{itemize}

\section{Сведения о системе}
\par Данная лабораторная работа выполнялась на двух виртуальных машинах, с соответсвующими ядрами.

\par Сведения о первой системе
\lstinputlisting{logs/sys-info-bubuntu12.txt}

\par Сведения о второй системе
\lstinputlisting{logs/sys-info-bubuntu14.txt}

\clearpage

\section{Выполнение работы}

\subsection{Системные вызовы} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Системный вызов — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.

\par Современные операционные системы предусматривают разделение времени между выполняющимися вычислительными процессами (многозадачность) и разделение полномочий, препятствующее обращению исполняемых программ к данным других программ и оборудованию. Ядро ОС исполняется в привилегированном режиме работы процессора. Для выполнения межпроцессной операции или операции, требующей доступа к оборудованию, программа обращается к ядру, которое, в зависимости от полномочий вызывающего процесса, исполняет либо отказывает в исполнении такого вызова.

\par С точки зрения программиста, системный вызов обычно выглядит как вызов подпрограммы или функции из системной библиотеки. Однако системный вызов, как частный случай вызова такой функции или подпрограммы, следует отличать от более общего обращения к системной библиотеке, поскольку последнее может и не требовать выполнения привилегированных операций.

\subsection{Заданные системные вызовы} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Для исследования, в данной лабораторной работе, были заданы следующие системные вызовы:

\begin{itemize}
    \item sys\_chmod 
    \item sys\_chown
\end{itemize}


\par Прежде всего необходимо привести сигнатуры данных функций.

\begin{center}
    \item \textbf{\#include <sys/stat.h>}
    \item \textbf{\##include <unistd.h>}
\end{center}

\begin{center}
    \item int chmod(const char *pathname, mode\_t mode); 
    \item int chown(const char *pathname, uid\_t owner, gid\_t group);
\end{center}

\par Системный вызов chmod() и  изменяет права доступа к файлу.
chmod() изменяет права доступа к файлу, заданному параметром pathname, который разыменовывается, если является символьной ссылкой. \\

\par Эффективный идентификатор пользователя (UID) вызывающего процесса должен совпадать с UID владельца файла или процесс должен быть привилегированным (Linux: у него должен быть мандат CAP\_FOWNER).

Если вызывающий процесс не является привилегированным (Linux: не имеет мандата CAP\_FSETID), а группа-владелец файла не совпадает с эффективным групповым ID процесса или одним из его дополнительных групповых идентификаторов, то бит S\_ISGID будет сброшен, но ошибки при этом не возникнет. \\


\par chown() изменяет владельца для файла, задаваемого параметром pathname, который разыменовывается, если является символьной ссылкой. \\

\par Только привилегированный процесс (Linux: имеющий мандат CAP\_CHOWN) может сменить владельца файла. Владелец файла может сменить группу файла на любую группу, в которой он числится. Привилегированный процесс (Linux: с CAP\_CHOWN) может задавать произвольную группу.

Если параметр owner или group равен -1, то соответствующий идентификатор не изменяется.

Когда владелец или группа исполняемого файла изменяется непривилегированным пользователем, то биты режима S\_ISUID и S\_ISGID сбрасываются. В POSIX не указано, должно ли это происходить если chown() выполняется суперпользователем; поведение в Linux зависит от версии ядра. В случае исполняемого файла вне группы (т.е., у которого не установлен бит S\_IXGRP) бит S\_ISGID указывает на обязательную блокировку, и не сбрасывается при выполнении chown().

\subsubsection{Возможные ошибки системных вызовов}
Наиболее распространённые ошибки перечислены далее:
\begin{itemize}
\item EACCES
Поиск запрещён из-за одного из частей префикса пути)
\item EFAULT
Аргумент pathname указывает за пределы доступного адресного пространства.
\item EIO
Произошла ошибка ввода-вывода.
\item ELOOP
Во время определения pathname встретилось слишком много символьных ссылок.
\item ENAMETOOLONG
Слишком длинное значение аргумента pathname.
\item ENOENT
Файл не существует.
\item ENOMEM
Недостаточное количество памяти ядра.
\item ENOTDIR
Компонент в префиксе пути не является каталогом.
\item EPERM
Эффективный UID не совпадает с идентификатором владельца файла, а процесс не является привилегированным (Linux: не имеет мандата CAP\_FOWNER).
\end{itemize}


\subsection{Анализ исходного кода chmod} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Исходный код системныго вызова chmod проанализирован для следующих ядер.

\subsubsection{Ядро 3.11.0-15-generic}

\par Ниже приведен исходный код chmod
\lstinputlisting{listings/chmod.txt}

\par $SYSCALL\_DEFINE2$ -- макрос используемый для определения системных вызовов, цифра 1 означает количество параметров у системного вызова.

\par В данном системном вызове используется функция $do\_fchmodat()$, ниже приведен её исходный код:

\lstinputlisting{listings/do_fchmodat.txt}


\subsubsection{Ядро 4.4.0-142-generic}

\par При поиске исходного кода chmod для ядра 4.x был найден абсолютно идентичный код относительно третьего ядра. Поэтому дублировать исходный код не имеет смысла.


\subsection{Анализ исходного кода chown} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Исходный код системныго вызова chown проанализирован для следующих ядер.

\subsubsection{Ядро 3.11.0-15-generic}

\par Ниже приведен исходный код chown
\lstinputlisting{listings/chown.txt}

\par $SYSCALL\_DEFINE3$ -- макрос используемый для определения системных вызовов, цифра 1 означает количество параметров у системного вызова. 

\par Вызов по сути использует функцию $do_fchowat$. Ее код приведен ниже

\lstinputlisting{listings/do_fchownat.txt}



\subsubsection{Ядро 4.4.0-142-generic}

\par При поиске исходного кода  chown для ядра 4.x был найден абсолютно идентичный код относительно третьего ядра. Поэтому дублировать исходный код не имеет смысла.


\subsection{Работа системных вызовов} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Напишем простые программы, которая изменит права доступа к файлу и владельца. Так как исходный код системных вызовов идентичен для ядер 3.11.0-15-generic и 4.4.0-142-generic, запускать будем только на одной системе с ядром 3.11.0-15-generic, так как результат в системе с ядром 4.х будет аналогичным. Ниже приведен исходный код, написанной программы:

\lstinputlisting{listings/chmod_sys_call.c}

\lstinputlisting{listings/chown_sys_call.c}

\par После компиляции и запуска программ получили следующее:

\lstinputlisting{logs/chmod_log.txt}

\lstinputlisting{logs/chown_log.txt}


\par Из результатов видно, что программы закончились успешно. Программа вызывающая системный вызов chmod() изменила права на 0005, а вызов chown() изменил права к файлу на того же пользователя.

\par Далее можно выполнить трассировку, написанной программы. Ниже представлен лог трассировки:

 \lstinputlisting{logs/strace_chmod.txt}


\par В результате трассировки видно, что  последовательность вызовов системных функций совпадает с ожидаемой.



\subsection{Перехват системных вызовов} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Ядро 3.11.0-15-generic}

\textbf{khook}

\par Данный способ перехвата системного вызова будет основываться на готовой библиотеке khook. Данная библиотека реализует перехват с помощью вносимых модификаций в пролог (начало) целевой функции таким образом, чтобы его выполнение процессором приводило передаче управления на функцию-обработчик. \\

\par Для каждой целевой функции осуществим модификацию пролога путём записи в её начало команды JMP . Это позволит переключить поток выполнения с целевой функции на соответствующий обработчик. \\ 

\par Например, если до перехвата функция inode\_permission имеет вид:

 \lstinputlisting{logs/theory-hook1.txt}

\par То после перехвата, пролог этой функции будет выглядеть следующим образом:

 \lstinputlisting{logs/theory-hook2.txt}

\par Именно записанная поверх оригинальных инструкций пяти-байтовая команда JMP с кодом E9.XX.XX.XX.XX приводит к передачи управления. В этом и состоит основная суть описываемого способа осуществления перехвата. Далее будут рассмотрены некоторые особенности его реализации в ядре Linux.

\par Как было отмечено, суть патчинга заключается в модификации кода ядра. Основной проблемой, возникающей при этом является то, что запись в страницы памяти, содержащие код невозможна так как в архитектуре x86 существует специальный защитный механизм, в соответствии с которым попытка записи в защищённые от записи области памяти может приводить к генерации исключения. Данный механизм носит название «страничной защиты» и является базовым для реализации многих функций ядра, таких, как например COW. Поведение процессора в этой ситуации определяется битом WP регистра CR0, а права доступа к странице описываются в соответствующей ей структуре-описателе PTE. При установленном бите WP регистра CR0 попытка записи в защищённые от записи страницы (cброшен бит RW в PTE) ведёт к генерации процессором соответствующего исключения (\#GP).

\par Зачастую, решением данной проблемы является временное отключение страничной защиты сбросом бита WP регистра CR0. Это решение имеет место быть, однако \textbf{применять его нужно с осторожностью}, ведь как было отмечено, механизм страничной защиты является \textbf{основой для многих механизмов ядра}. Кроме того, на SMP-системах, поток, выполняющийся на одном из процессоров и там же снимающий бит WP, может быть прерван и перемещён на другой процессор!

\par Более лучшим и в достаточной степени универсальным, является способ создания временных отображений. В силу особенностей работы MMU, для каждого физического фрейма памяти может быть создано несколько ссылающихся на него описателей, имеющих различные атрибуты. Это позволяет создать для целевой области памяти отображение, доступное для записи. Ниже приведена функция map\_writable, которая и создаёт такое отображение:

\clearpage

\lstinputlisting{logs/theory-hook3.txt}

\par Использование данной функции позволит создать доступное для записи отображение для любой области памяти. Освобождение созданного таким образом региона осуществляется с использованием функции vfree, аргументом которой должно служить выравненное на границу страницы значение адреса.\\

\textbf{Попытка перехвата}

\par Напишем модуль ядра для перехвата системных вызовов:

\lstinputlisting{listings/khook.c}

\par Далее скомпилируем модуль:

\lstinputlisting[firstline=1, lastline=12]{logs/khook_log.txt}

\par Далее загрузим получившийся модуль:

\lstinputlisting[firstline=13, lastline=13]{logs/khook_log.txt}

\par Далее запустим приложение, демонстрирующее работы системных вызовов:

\lstinputlisting[firstline=15, lastline=20]{logs/khook_log.txt}


\par После всех выполненных манипуляций убедимся, что перехват системных вызовов был выполнен. Для этого посмотрим лог ядра:

\lstinputlisting[firstline=21, lastline=25]{logs/khook_log.txt}





\subsubsection{Ядро 4.4.0-142-generic} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\par Начиная с версии ядра 3.19 перехват системных вызовов с помощью фреймворка ftrace, на ОС семейства Linux x86\_64, работает штатно.

\par Реализуется ftrace на основе ключей компилятора -pg и -mfentry, которые вставляют в начало каждой функции вызов специальной трассировочной функции mcount() или \_\_fentry\_\_(). Обычно, в пользовательских программах эта возможность компилятора используется профилировщиками, чтобы отслеживать вызовы всех функций. Ядро же использует эти функции для реализации фреймворка ftrace.

\par Вызывать ftrace из каждой функции -- это, разумеется, не дёшево, поэтому для популярных архитектур доступна оптимизация: динамический ftrace. Суть в том, что ядро знает расположение всех вызовов mcount() или \_\_fentry\_\_() и на ранних этапах загрузки заменяет их машинный код на nop — специальную ничего не делающую инструкцию. При включении трассирования в нужные функции вызовы ftrace добавляются обратно. Таким образом, если ftrace не используется, то его влияние на систему минимально.

\par Рассмотрим необходимую для работы с ftrace структуру:

\lstinputlisting[firstline=45, lastline=52]{listings4/ftrace_hook.c}

\begin{itemize}
	\item name -- имя перехватываемой функции
	\item function -- адрес функции обработчика 
	\item original -- указатель на ячейку для хранения адреса оригинального обработчика
	\item address -- адрес перехватываемой функции, заполняется во время перехвата
	\item ops -- место под сервисную информацию
\end{itemize}

\par Для работы необходимо заполнить только три поля данной структуры: \lstinline|name, function, original|. Для удобства использования можно применить макрос:

\lstinputlisting[firstline=234, lastline=237]{listings/ftrace_hook.c}

\par Напишем свои функции перехвата для chmod и chown.

\par Сначала приводим сигнатуры функций:
\lstinputlisting[firstline=186, lastline=187]{listings/ftrace_hook.c}

\par Важно учесть оригинальную сигнатуру функции, она должна полностью соответствовать используемой в перехвате, в противном случае существует риск получить невалидные аргументы, что скажется на работе всей функции и перехвата в целом.

\par Далее приводим реализацию функций:
\lstinputlisting[firstline=189, lastline=208]{listings/ftrace_hook.c}


\par Прежде всего надо найти и сохранить адрес перехватываемой функции. Для этого воспользуемся \textit{kallsyms} -- список всех символов в ядре. Так выглядит функция поиска:

\lstinputlisting[firstline=54, lastline=66]{listings4/ftrace_hook.c}

\par Теперь необходимо инициализировать \lstinline|ops| структуру, \lstinline|func| указатель на обратный вызов и флаги: 

\lstinputlisting[firstline=83, lastline=110]{listings4/ftrace_hook.c}

\lstinline|fh\_ftrace\_thunk ()| -- это обратный вызов который используется при трассировке функции. Флаги необходимы для сохранения и восстановления состояния регистров процессора. 

\par Для установки перехвата сначала запускается ftrace для необходимой функции \lstinline|ftrace\_set\_filter\_ip()|, затем используется\lstinline|register\_ftrace\_function()| для передачи ftrace необходимых для обратного вызова прав.

\par Для дезактивации перехвата необходимо повторить те же самые действия в обратном порядке:

\lstinputlisting[firstline=116, lastline=129]{listings4/ftrace_hook.c}

\clearpage

\par Далее компилируем модуль ядра
\lstinputlisting[firstline=1, lastline=16]{logs/ftrace_log.txt}

\par Установим получившийся модуль, и запустим приложение, которое проверяет работу системных вызовов

\lstinputlisting[firstline=17, lastline=28]{logs/ftrace_log.txt}


\par После всех выполненных манипуляций убедимся, что перехват системных вызовов был выполнен. Для этого посмотрим лог ядра:

\lstinputlisting[firstline=29, lastline=33]{logs/ftrace_log.txt}

\par Из лога видно, что модуль был загружен, затем были перехвачены системные вызовы, и в конце модуль был выгружен. Перехват системных вызовов был выполнен в том же порядке, как и в программе, демонстрирующей работы системных вызовов.

\subsection{Вывод} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\par В ходе выполнения данной лабораторной работы были исследованы системные вызов \textbf{chmod} и \textbf{chown}. Для данных системных вызовов был: проанализирован исходный код (в различных версиях ядер), а также написан тестовый пример использования и был произведен перехват.

\clearpage

\input{literarture.tex}

\end{document}